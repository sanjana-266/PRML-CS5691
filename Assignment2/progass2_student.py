# -*- coding: utf-8 -*-
"""ProgAss2_Student.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q_wFj8Yxw6Bxhybn91VjqGPTai4y7w4j

# General Instructions to students:

1. There are 5 types of cells in this notebook. The cell type will be indicated within the cell.
    1. Markdown cells with problem written in it. (DO NOT TOUCH THESE CELLS) (**Cell type: TextRead**)
    2. Python cells with setup code for further evaluations. (DO NOT TOUCH THESE CELLS) (**Cell type: CodeRead**)
    3. Python code cells with some template code or empty cell. (FILL CODE IN THESE CELLS BASED ON INSTRUCTIONS IN CURRENT AND PREVIOUS CELLS) (**Cell type: CodeWrite**)
    4. Markdown cells where a written reasoning or conclusion is expected. (WRITE SENTENCES IN THESE CELLS) (**Cell type: TextWrite**)
    5. Temporary code cells for convenience and TAs. (YOU MAY DO WHAT YOU WILL WITH THESE CELLS, TAs WILL REPLACE WHATEVER YOU WRITE HERE WITH OFFICIAL EVALUATION CODE) (**Cell type: Convenience**)
    
2. You are not allowed to insert new cells in the submitted notebook.

3. You are not allowed to import any extra packages.

4. The code is to be written in Python 3.6 syntax. Latest versions of other packages maybe assumed.

5. In CodeWrite Cells, the only outputs to be given are plots asked in the question. Nothing else to be output/print. 

6. If TextWrite cells ask you to give accuracy/error/other numbers you can print them on the code cells, but remove the print statements before submitting.

7. The convenience code can be used to check the expected syntax of the functions. At a minimum, your entire notebook must run with "run all" with the convenience cells as it is. Any runtime failures on the submitted notebook as it is will get zero marks.

8. All code must be written by yourself. Copying from other students/material on the web is strictly prohibited. Any violations will result in zero marks.

9. All datasets will be given as .npz files, and will contain data in 4 numpy arrays :"X_train, Y_train, X_test, Y_test". In that order. The meaning of the 4 arrays can be easily inferred from their names.

10. All plots must be labelled properly, all tables must have rows and columns named properly.

11. Before subbmission ensure that you submit with the outputs (do not clear the outputs), so that when evaluating we can run selectively.

12. Before submission ensure that the path for the folder containing the data is "../../Data/"
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm
import matplotlib as mpl
import pandas as pd

from google.colab import drive
drive.mount('/content/gdrive')

cd gdrive/MyDrive/

"""# 1. Logistic Regression 

Write code for doing logistic regression below. Also write code for choosing best hyperparameters for each kernel type (use a part of training set as validation set). 

The range of hyperparameters is typically chosen on a log scale e.g. 1e-4, 1e-3, 1e-2... 1e3.

Write code for running in the cell after (You may be asked to demonstrate your code during the viva using this cell.)

In text cell after that report the following numbers you get by running appropriate code:

For each classification data set report the best kernel and regularisation parameters for linear, RBF and Poly kernels. (Linear has no kernel parameter.) Report the training and test zero-one error for those hyperparameters. 

For each given hyperparameter setting (kernel and regularisation) you will have to do some exploring to find the right learning rate to use in gradient descent. The optimisation learning rate is not a model hyperparameter and hence can be chosen based on just the training set. i.e. choose the learning rate for which the training loss decreases the most.

For the synthetic classification datasets (dataset_A and dataset_B) in 2-dimensions, also illustrate the learned classifier for each kernel setting. Do this in the last codeWrite cell for this question.

"""

# CodeWrite 
#Write logistic regression code from scratch. Use gradient descent.
# Only write functions here

def train_pred_logistic_regression(X, Y, kernel='linear', reg_param=0., kernel_param=1., num_iter_gd=100):
  
    n = X.shape[0]
    K = np.zeros([n,n])

    if kernel == 'linear':

      K = linear_kernel(X, X)

    if kernel == 'poly':

      K = polynomial_kernel(X, X, kernel_param, 1)

    if kernel == 'rbf':

      for i in range(n):
        for j in range(n):
          K[i,j] = np.exp(-kernel_param*np.linalg.norm(X[i]-X[j])**2)

    alpha = np.random.randn(n,1)

    learning_rate = 0.01

    sum = np.zeros([n,n])

    for j in range(num_iter_gd):
      p = 0
      for i in range(n):

        s = -Y[i]*np.dot(alpha.T,K[:,i])    

        
        p += sigmoid(s)*(-Y[i]*K[:,i])
        

      
      
      
      gradient = p.reshape(-1,1) + reg_param*np.dot(K,alpha)

      
      
      alpha = alpha - learning_rate*gradient
      #print(np.shape(alpha),j,'w')
      #print(np.shape(gradient),j,'l')

      
    return alpha

def sigmoid(u):

  if u>=100:

    return 1

  if u<=-100:

    return 0

  return 1/(1+np.exp(-u))

def test_pred(alpha, train_X, train_Y, test_X, kernel, kernel_param):
    """
    Return the predictions on test_X using the learnt alphas
    """
    
    n_train = train_X.shape[0]
    n_test = test_X.shape[0]
    K = np.zeros([n_train,n_test])

    if kernel == 'linear':

      K = linear_kernel(train_X, test_X)

    if kernel == 'poly':

      K = polynomial_kernel(train_X, test_X, kernel_param, 1)

    if kernel == 'rbf':

      for i in range(n_train):
        for j in range(n_test):
          K[i,j] = np.exp(-kernel_param*np.linalg.norm(train_X[i]-test_X[j])**2)

    
    pred_Y = np.sign(alpha.T@K)
    pred_Y = pred_Y.reshape(-1,1)

    print('done')
    return pred_Y
    
def linear_kernel(X,Y):
    
    assert X.shape[1] == Y.shape[1]

    K = np.matmul(X,Y.T)
    return K

def polynomial_kernel(X,Y,kernel_param,bias):
    
    assert X.shape[1] == Y.shape[1]
    
    K = np.matmul(X,Y.T)
    K = K + bias
    K = np.power(K,kernel_param) 
    return K

"""Arguments:
    X : (n,d) shape numpy array
    Y : (n,)  shape numpy array
    X_test : (m,d) shape numpy array
    kernel = 'linear' or 'rbf' or 'poly' 
    reg_param = $\lambda$
    num_iter_gd = number of GD iterations.

    Returns the result of kernel logistic regression :
    alpha: Vector of solutions for the dual. Numpy array of shape (n,)

    Primal problem:
    $ \min_w  \sum_{i=1}^n \log(1+\exp(-y_i* \w^\top \phi(\x_i)))  + \frac{\lambda}{2} ||\w||^2 $

    the dual of which is

    $ \min_alpha \sum_{i=1}^n \log(1+\exp(-y_i* \alpha^\top K_{:,i} ))  + \frac{\lambda}{2} \alpha^\top K \alpha $
    where $\phi$ is the feature got by the kernel.

    Where K is the nxn kernel matrix computed on the training data.

    The kernel is defined by the kernel_param:
    If kernel=linear: K(\u,\v) = \u^\top \v  
    If kernel=poly:  K(\u,\v) = (1+\u^\top \v)^(kernel_param)
    If kernel=rbf:  K(\u,\v) = \exp(-kernel_param*||\u-\v||^2)
    """

# CodeWrite : Use the functions above to do validation to get best hyperparameters 
# (i.e. kernel_param and regularisation_param).
# Also, get the numbers you report below. 

test_err_linear = np.zeros(4)
test_err_poly = np.zeros(4)
test_err_rbf = np.zeros(4)
train_err_linear = np.zeros(4)
train_err_poly = np.zeros(4)
train_err_rbf = np.zeros(4)

data1_1 = np.load('Data/dataset_A.npz')

X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']

Y_test = Y_test.reshape(-1,1)
Y_train = Y_train.reshape(-1,1)

alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=1e-4, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='linear', kernel_param = 1)

test_err_linear[0] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='linear', kernel_param = 1)

train_err_linear[0] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=1e-4, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='poly', kernel_param = 1)

test_err_poly[0] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='poly', kernel_param = 1)

train_err_poly[0] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=1e-4, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='rbf', kernel_param = 1)

test_err_rbf[0] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='rbf', kernel_param = 1)

train_err_rbf[0] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



data1_1 = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
Y_test = Y_test.reshape(-1,1)
Y_train = Y_train.reshape(-1,1)

alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=1, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='linear', kernel_param = 1)

test_err_linear[1] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='linear', kernel_param = 1)

train_err_linear[1] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=1, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='poly', kernel_param = 1)

test_err_poly[1] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='poly', kernel_param = 1)

train_err_poly[1] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=1e-2, kernel_param=10, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='rbf', kernel_param = 10)

test_err_rbf[1] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='rbf', kernel_param = 10)

train_err_rbf[1] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)

data1_1 = np.load('Data/dataset_C.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
Y_test = Y_test.reshape(-1,1)
Y_train = Y_train.reshape(-1,1)
print(np.shape(X_train),np.shape(X_test))
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=1e-4, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='linear', kernel_param = 1)

test_err_linear[2] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='linear', kernel_param = 1)

train_err_linear[2] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=1e-4, kernel_param=1e-4, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='poly', kernel_param = 1e-4)

test_err_poly[2] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='poly', kernel_param = 1e-4)

train_err_poly[2] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=1e-4, kernel_param=1e-3, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='rbf', kernel_param = 1e-3)

test_err_rbf[2] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='rbf', kernel_param = 1e-3)

train_err_rbf[2] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)

data1_1 = np.load('Data/dataset_D.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
Y_test = Y_test.reshape(-1,1)
Y_train = Y_train.reshape(-1,1)


alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=1e-4, kernel_param=1, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='linear', kernel_param = 1)

test_err_linear[3] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='linear', kernel_param = 1)

train_err_linear[3] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=1e-4, kernel_param=1e-4, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='poly', kernel_param = 1e-4)

test_err_poly[3] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='poly', kernel_param = 1e-4)

train_err_poly[3] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)



alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=1e-4, kernel_param=1e-2, num_iter_gd=100)

pred_Y = test_pred(alpha, X_train, Y_train, X_test, kernel='rbf', kernel_param = 1e-2)

test_err_rbf[3] = 1 - len(Y_test[Y_test==pred_Y])/len(Y_test)

pred_Y = test_pred(alpha, X_train, Y_train, X_train, kernel='rbf', kernel_param = 1e-2)

train_err_rbf[3] = 1 - len(Y_train[Y_train==pred_Y])/len(Y_train)

#print(reg_param_vals[linear_optimal_a],reg_param_vals[linear_optimal_b],reg_param_vals[linear_optimal_c],reg_param_vals[linear_optimal_d])
#print(kernel_param_vals[poly_optimal_kernel_a],kernel_param_vals[poly_optimal_kernel_b],kernel_param_vals[poly_optimal_kernel_c],kernel_param_vals[poly_optimal_kernel_d])
#print(reg_param_vals[poly_optimal_reg_a],reg_param_vals[poly_optimal_reg_b],reg_param_vals[poly_optimal_reg_c],reg_param_vals[poly_optimal_reg_d])
#print(kernel_param_vals[rbf_optimal_kernel_a],kernel_param_vals[rbf_optimal_kernel_b],kernel_param_vals[rbf_optimal_kernel_c],kernel_param_vals[rbf_optimal_kernel_d])
#print(reg_param_vals[rbf_optimal_reg_a],reg_param_vals[rbf_optimal_reg_b],reg_param_vals[rbf_optimal_reg_c],reg_param_vals[rbf_optimal_reg_d])
print(test_err_linear)
print(train_err_linear)
print(test_err_poly)
print(train_err_poly)
print(test_err_rbf)
print(train_err_rbf)

"""TextWrite Cell: Give your observations and the list of hyperparameter choices and train zero-one error  and test zero-one error for all three kernel choices, for all 4 datasets (2 real world and 2 synthetic).  

For linear kernel : 

Dataset | Regularisation parameter | Train zero-one error | Test zero-one error
--- |--- |--- |---
A | 0.0001 | 22.3 | 22.2
B | 1 | 18.06 | 21
C | 0.0001 | 49.7| 48.8
D | 0.0001 | 56.7 | 76.9

For poly kernel : 

Dataset | Kernel parameter | Regularisation parameter | Train zero-one error | Test zero-one error
--- |--- | --- |--- |---
A | 1 | 0.0001 | 16.2 | 16.4
B |1 | 0.001 | 25.7 | 25.6
C |0.0001 | 0.0001 | 49.7 | 48.6
D |0.0001 | 0.0001 | 56.7 | 76.9

For rbf kernel : 

Dataset | Kernel parameter | Regularisation parameter | Train zero-one error | Test zero-one error
--- |--- | --- |--- |---
A | 1 | 0.0001 | 0.26 | 0.4
B | 10 | 0.01 | 21.2 | 25.2
C | 0.001 | 0.0001 | 2.06 | 7.4
D | 0.01 | 0.0001 | 18.2 | 20.7
"""

# Codewrite cell: Generate plots of learned classifier for all three kernel types, on dataset_A and datasset_B.
# Plots should give both the learned classifier and the train data. 
# Similar to  Bishop Figure 4.5 (with just two classes here.)
# Total number of plots = 3 * 2 = 6

data_A = np.load('Data/dataset_A.npz')
X_train, Y_train, X_test, Y_test = data_A['arr_0'],data_A['arr_1'],data_A['arr_2'],data_A['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])


X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=0.0001, kernel_param=1, num_iter_gd=100)
pred_y_a = test_pred(alpha, X_train, Y_train, test_samples, kernel='linear',kernel_param= 1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=0.0001, kernel_param=1, num_iter_gd=100)
pred_y_b = test_pred(alpha, X_train, Y_train, test_samples, kernel='poly',kernel_param= 1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=0.0001, kernel_param=1, num_iter_gd=100)
pred_y_c = test_pred(alpha, X_train, Y_train, test_samples, kernel='rbf',kernel_param= 1)

plt.figure(0)
f, (ax1,ax2,ax3) = plt.subplots(1,3,sharex=False,sharey=True,figsize=(15,5))
ax1.contourf(X,Y,pred_y_a.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('LRC with linear kernel on Dataset A')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 

ax2.contourf(X,Y,pred_y_b.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax2.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax2.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label="Class -1")
ax2.set_title('LRC with polynomial kernel on Dataset A')
ax2.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax2.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax2.legend()
ax3.contourf(X,Y,pred_y_c.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax3.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax3.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label='Class -1')
ax3.set_title('LRC with rbf kernel on Dataset A')
ax3.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax3.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax3.legend()
plt.show()

data_B = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data_B['arr_0'],data_B['arr_1'],data_B['arr_2'],data_B['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])

X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='linear', reg_param=1, kernel_param=1, num_iter_gd=100)
pred_y_a = test_pred(alpha, X_train, Y_train, test_samples, kernel='linear',kernel_param= 1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='poly', reg_param=0.001, kernel_param=1, num_iter_gd=100)
pred_y_b = test_pred(alpha, X_train, Y_train, test_samples, kernel='poly',kernel_param= 1)
alpha = train_pred_logistic_regression(X_train, Y_train, kernel='rbf', reg_param=0.01, kernel_param=10, num_iter_gd=100)
pred_y_c = test_pred(alpha, X_train, Y_train, test_samples, kernel='rbf',kernel_param= 10)

plt.figure(0)
f, (ax1,ax2,ax3) = plt.subplots(1,3,sharex=False,sharey=True,figsize=(15,5))
ax1.contourf(X,Y,pred_y_a.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('LRC with linear kernel on Dataset B')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 

ax2.contourf(X,Y,pred_y_b.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax2.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax2.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label="Class -1")
ax2.set_title('LRC with polynomial kernel on Dataset B')
ax2.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax2.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax2.legend()
ax3.contourf(X,Y,pred_y_c.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax3.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax3.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label='Class -1')
ax3.set_title('LRC with rbf kernel on Dataset B')
ax3.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax3.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax3.legend()
plt.show()

"""# 2. SVM

Write code for learning SVM below. Also write code for choosing best hyperparameters for each kernel type. You may use sklearn.svm for this purpose. (use a part of training set as validation set)

Write code for running in the cell after (You may be asked to demonstrate your code during the viva using this cell.)

In text cell after that report the following numbers you get by running appropriate code:

For each classification data set report the best kernel and regularisation parameters for linear, RBF and Poly kernels. (Linear has no kernel parameter.) Report the training and test zero-one error for those hyperparameters.

For the synthetic classification datasets in 2-dimensions, also illustrate the learned classifier for each kernel setting. Do this in the last codeWrite cell for this question.
"""

# CodeWrite cell
# Write SVM classifier using SKlearn
# write only functions here

def train_pred_svm(X, Y, X_test, kernel='linear', reg_param=0., kernel_param=1., degree=1):

  classifier = svm.SVC(C = reg_param, kernel = kernel, degree = degree, gamma = kernel_param)

  classifier.fit(X,Y)

  pred_y = classifier.predict(X_test)

  return pred_y

# CodeWrite cell
# Write code here for doing validation (for kernel_param and regularisation_param)
# on a subset of the training set. 
# Also for generating the numbers that you report below.

data1_1 = np.load('Data/dataset_A.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']

kernel_param_vals = [1e-4,1e-3,1e-2,1e-1,1,10]
reg_param_vals = [1e-4,1e-3,1e-2,1e-1,1,10]
n1 = len(kernel_param_vals)
n2 = len(reg_param_vals)

linear_validation_error = np.zeros((n1,n2,3))
poly_validation_error = np.zeros((n1,n2,3))
rbf_validation_error = np.zeros((n1,n2,3))
X_validation = X_train[:200,:]
Y_validation = Y_train[:200]

for i in range(len(kernel_param_vals)):
  for j in range(len(reg_param_vals)):
    for k in range(3):

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='linear', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)
      
      linear_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='poly', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      poly_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='rbf', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      rbf_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

linear_optimal_a = np.where(linear_validation_error == np.amin(linear_validation_error))[1][0]
poly_optimal_kernel_a = np.where(poly_validation_error == np.amin(poly_validation_error))[0][0]
poly_optimal_reg_a = np.where(poly_validation_error == np.amin(poly_validation_error))[1][0]
poly_optimal_degree_a = np.where(poly_validation_error == np.amin(poly_validation_error))[2][0]
rbf_optimal_kernel_a = np.where(rbf_validation_error == np.amin(rbf_validation_error))[0][0]
rbf_optimal_reg_a = np.where(rbf_validation_error == np.amin(rbf_validation_error))[1][0]
print('dataset A',"linear error",linear_validation_error[0,linear_optimal_a,0],"poly error",poly_validation_error[poly_optimal_kernel_a,poly_optimal_reg_a,poly_optimal_degree_a],"rbf error",rbf_validation_error[rbf_optimal_kernel_a,rbf_optimal_reg_a,0])

data1_1 = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
X_validation = X_train[:200,:]
Y_validation = Y_train[:200]

for i in range(len(kernel_param_vals)):
  for j in range(len(reg_param_vals)):
    for k in range(3):

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='linear', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)
      
      linear_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='poly', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      poly_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='rbf', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      rbf_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

linear_optimal_b = np.where(linear_validation_error == np.amin(linear_validation_error))[1][0]
poly_optimal_kernel_b = np.where(poly_validation_error == np.amin(poly_validation_error))[0][0]
poly_optimal_reg_b = np.where(poly_validation_error == np.amin(poly_validation_error))[1][0]
poly_optimal_degree_b = np.where(poly_validation_error == np.amin(poly_validation_error))[2][0]
rbf_optimal_kernel_b = np.where(rbf_validation_error == np.amin(rbf_validation_error))[0][0]
rbf_optimal_reg_b = np.where(rbf_validation_error == np.amin(rbf_validation_error))[1][0]
print('dataset B',"linear error",linear_validation_error[0,linear_optimal_b,0],"poly error",poly_validation_error[poly_optimal_kernel_b,poly_optimal_reg_b,poly_optimal_degree_b],"rbf error",rbf_validation_error[rbf_optimal_kernel_b,rbf_optimal_reg_b,0])

data1_1 = np.load('Data/dataset_C.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
X_validation = X_train[:200,:]
Y_validation = Y_train[:200]

for i in range(len(kernel_param_vals)):
  for j in range(len(reg_param_vals)):
    for k in range(3):

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='linear', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)
      
      linear_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='poly', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      poly_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='rbf', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      rbf_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)


linear_optimal_c = np.where(linear_validation_error == np.amin(linear_validation_error))[1][0]
poly_optimal_kernel_c = np.where(poly_validation_error == np.amin(poly_validation_error))[0][0]
poly_optimal_reg_c = np.where(poly_validation_error == np.amin(poly_validation_error))[1][0]
poly_optimal_degree_c = np.where(poly_validation_error == np.amin(poly_validation_error))[2][0]
rbf_optimal_kernel_c = np.where(rbf_validation_error == np.amin(rbf_validation_error))[0][0]
rbf_optimal_reg_c = np.where(rbf_validation_error == np.amin(rbf_validation_error))[1][0]

print('dataset C',"linear error",linear_validation_error[0,linear_optimal_c,0],"poly error",poly_validation_error[poly_optimal_kernel_c,poly_optimal_reg_c,poly_optimal_degree_c],"rbf error",rbf_validation_error[rbf_optimal_kernel_c,rbf_optimal_reg_c,0])

print(reg_param_vals[linear_optimal_a],reg_param_vals[linear_optimal_b],reg_param_vals[linear_optimal_c])
print(kernel_param_vals[poly_optimal_kernel_a],kernel_param_vals[poly_optimal_kernel_b],kernel_param_vals[poly_optimal_kernel_c])
print(reg_param_vals[poly_optimal_reg_a],reg_param_vals[poly_optimal_reg_b],reg_param_vals[poly_optimal_reg_c])
print(poly_optimal_reg_a+1,poly_optimal_reg_b+1,poly_optimal_reg_c+1)
print(kernel_param_vals[rbf_optimal_kernel_a],kernel_param_vals[rbf_optimal_kernel_b],kernel_param_vals[rbf_optimal_kernel_c])
print(reg_param_vals[rbf_optimal_reg_a],reg_param_vals[rbf_optimal_reg_b],reg_param_vals[rbf_optimal_reg_c])

data1_1 = np.load('Data/dataset_D.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
X_validation = X_train[:200,:]
Y_validation = Y_train[:200]

for i in range(len(kernel_param_vals)):
  for j in range(len(reg_param_vals)):
    for k in range(3):

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='linear', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)
      
      linear_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='poly', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      poly_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

      pred_y = train_pred_svm(X_train, Y_train, X_validation, kernel='rbf', reg_param=reg_param_vals[j], kernel_param=kernel_param_vals[i], degree=k+1)

      rbf_validation_error[i,j,k]  = 1-len(Y_validation[pred_y==Y_validation])/len(Y_validation)

linear_optimal_d = np.where(linear_validation_error == np.amin(linear_validation_error))[1][0]
poly_optimal_kernel_d = np.where(poly_validation_error == np.amin(poly_validation_error))[0][0]
poly_optimal_reg_d = np.where(poly_validation_error == np.amin(poly_validation_error))[1][0]
poly_optimal_degree_d = np.where(poly_validation_error == np.amin(poly_validation_error))[2][0]
rbf_optimal_kernel_d = np.where(rbf_validation_error == np.amin(rbf_validation_error))[0][0]
rbf_optimal_reg_d = np.where(rbf_validation_error == np.amin(rbf_validation_error))[1][0]

print('dataset D',"linear error",linear_validation_error[0,linear_optimal_d,0],"poly error",poly_validation_error[poly_optimal_kernel_d,poly_optimal_reg_d,poly_optimal_degree_d],"rbf error",rbf_validation_error[rbf_optimal_kernel_d,rbf_optimal_reg_d,0])

"""TextWrite Cell: Give your observations and the list of hyperparameter choices and train zero-one error  and test zero-one error for all three kernel choices, for all 4 datasets (2 real world and 2 synthetic).  

"""

# Codewrite cell: Generate plots of learned classifier for all three kernel types, on dataset_A and datasset_B.
# Plots should give both the learned classifier and the train data. 
# Similar to  Bishop Figure 4.5 (with just two classes here.)
# Total number of plots = 3 * 2 = 6

data_A = np.load('Data/dataset_A.npz')
X_train, Y_train, X_test, Y_test = data_A['arr_0'],data_A['arr_1'],data_A['arr_2'],data_A['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])


X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
pred_y_a = train_pred_svm(X_train, Y_train, test_samples, kernel='linear', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)
pred_y_b = train_pred_svm(X_train, Y_train, test_samples, kernel='poly', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)
pred_y_c = train_pred_svm(X_train, Y_train, test_samples, kernel='rbf', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)

plt.figure(0)
f, (ax1,ax2,ax3) = plt.subplots(1,3,sharex=False,sharey=True,figsize=(15,5))
ax1.contourf(X,Y,pred_y_a.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('SVM Classifier with linear kernel on Dataset A')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 

ax2.contourf(X,Y,pred_y_b.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax2.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax2.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label="Class -1")
ax2.set_title('SVM Classifier with polynomial kernel on Dataset A')
ax2.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax2.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax2.legend()
ax3.contourf(X,Y,pred_y_c.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax3.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax3.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label='Class -1')
ax3.set_title('SVM Classifier with rbf kernel on Dataset A')
ax3.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax3.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax3.legend()
plt.show()

data_B = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data_B['arr_0'],data_B['arr_1'],data_B['arr_2'],data_B['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])

X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
pred_y_a = train_pred_svm(X_train, Y_train, test_samples, kernel='linear', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)
pred_y_b = train_pred_svm(X_train, Y_train, test_samples, kernel='poly', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)
pred_y_c = train_pred_svm(X_train, Y_train, test_samples, kernel='rbf', reg_param=, kernel_param=kernel_param_vals[i], degree=k+1)

plt.figure(0)
f, (ax1,ax2,ax3) = plt.subplots(1,3,sharex=False,sharey=True,figsize=(15,5))
ax1.contourf(X,Y,pred_y_a.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('SVM Classifier with linear kernel on Dataset B')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 

ax2.contourf(X,Y,pred_y_b.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax2.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax2.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label="Class -1")
ax2.set_title('SVM Classifier with polynomial kernel on Dataset B')
ax2.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax2.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax2.legend()
ax3.contourf(X,Y,pred_y_c.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax3.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g', label='Class 1')
ax3.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d', label='Class -1')
ax3.set_title('SVM Classifier with rbf kernel on Dataset B')
ax3.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax3.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax3.legend()
plt.show()

"""# 3. Decision Tree

Write code for learning decision tree below. Take as an argument a hyperparameter on what size node to stop splitting. Use a part of training set as validation set.

Write code for running in the cell after (You may be asked to demonstrate your code during the viva using this cell.)

In text cell after that report the following numbers you get by running appropriate code:

For all four data sets  report the best node size to stop splitting. Report the training and test zero-one error for those hyperparameters.

For datasets A and B, also illustrate the learned classifier. Do this in the last codeWrite cell for this question.

Important: Think about how you will represent a decision tree. (Possible soln: Store as a list of tuples containing node position, attribute to split, threshold, class to classifiy (if leaf node) )

"""

# CodeWrite cell
# Write Decision tree classifier from scratch, 
# write only functions here (you may write extra functions here if you wish)
def train_decision_tree(X, Y, num_nodes_stop=1, criterion='accuracy'):

#Returns a decision tree trained on X and Y. 
#Stops splitting nodes when a node has hit a size of "num_nodes_stop" or lower.
#Split criterion can be either 'accuracy' or 'entropy'.
#Returns a tree (In whatever format that you find appropriate)


  attribute_number = X.shape[1]
  min_threshold = np.zeros(attribute_number)
  max_threshold = np.zeros(attribute_number)

  for i in range(attribute_number):

    min_threshold[i] = np.min(X[:,i])
    max_threshold[i] = np.max(X[:,i])
    
  tree = {}

  split_count = 100
  node = 1
  
  Y_new = Y
  X_new = X
  nodes = 0
  while node>0:
    max = 0
    pos_Y = Y_new[Y_new==1]
    if len(pos_Y)==0:
      min = 0
    if len(pos_Y)==len(Y_new):
      entropy = 0
    if len(pos_Y)>0 and len(pos_Y)<len(Y_new):
      min = entropy_cal(len(pos_Y)/len(Y_new))
    entropy = min
    
    for attribute_choice in range(attribute_number):
      for i in range(split_count-1):
        step = (max_threshold[attribute_choice]-min_threshold[attribute_choice])*(i+1)/split_count
        decision_yes = Y_new[X_new[:,attribute_choice]>=min_threshold[attribute_choice]+step]
        decision_no = Y_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]
        decision_yes_pos = decision_yes[decision_yes==1]
        decision_no_neg = decision_no[decision_no==-1]
        acc_yes_pos = (len(decision_yes_pos)+len(decision_no_neg))/len(Y_new)
        acc_yes_neg = 1-acc_yes_pos
     
        if len(decision_yes)==0:
          entropy = 0
        if len(decision_no)==0:
          entropy = 0
        if len(decision_no)>0 and len(decision_yes)>0:
          entropy = (len(decision_yes)*entropy_cal(len(decision_yes_pos)/len(decision_yes))+len(decision_no)*entropy_cal(len(decision_no_neg)/len(decision_no)))/len(Y_new)
        if criterion == 'accuracy':
          if acc_yes_pos>acc_yes_neg:
            if acc_yes_pos>max:
              max = acc_yes_pos
              attribute_optimal = attribute_choice
              max_thres = min_threshold[attribute_choice]+step
              leaf = '1'
              nodes = len(decision_no)
              Y_new_temp = Y_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]
              X_new_temp = X_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]

          if acc_yes_neg>acc_yes_pos:
            if acc_yes_neg>max:
              max = acc_yes_neg
              attribute_optimal = attribute_choice
              max_thres = min_threshold[attribute_choice]+step
              leaf = '-1'
              nodes = len(decision_no)
              Y_new_temp = Y_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]
              X_new_temp = X_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]

        if criterion == 'entropy':
          if entropy<min:
            min = entropy
            attribute_optimal = attribute_choice
            max_thres = min_threshold[attribute_choice]+step
            nodes = len(decision_no)
            Y_new_temp = Y_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]
            X_new_temp = X_new[X_new[:,attribute_choice]<min_threshold[attribute_choice]+step]
            if acc_yes_pos>acc_yes_neg:
              leaf = '1'
            if acc_yes_pos<acc_yes_neg:
              leaf = '-1'

    if nodes<num_nodes_stop:
      if node>1:

        tree[node] = [attribute_optimal,max_thres,'none']
        if leaf=='1':
          tree[node+3] = ['none','none','1']
          tree[node+2] = ['none','none','-1']
        if leaf=='-1':
          tree[node+3] = ['none','none','-1']
          tree[node+2] = ['none','none','1']

      if node==1:
      
        tree[node] = [attribute_optimal,max_thres,'none']
        if leaf=='1':
          tree[node+2] = ['none','none','1']
          tree[node+1] = ['none','none','-1']
        if leaf=='-1':
          tree[node+2] = ['none','none','-1']
          tree[node+1] = ['none','none','1']

      break;
    
    if node>1:

      tree[node] = [attribute_optimal,max_thres,'none']
      tree[node+3] = ['none','none',leaf]
      node = node + 2

    if node==1:
      
      tree[node] = [attribute_optimal,max_thres,'none']
      tree[node+2] = ['none','none',leaf]
      node = node + 1
    
    Y_new = Y_new_temp
    X_new = X_new_temp
    max_threshold[attribute_optimal] = max_thres

  print(tree)
  return tree

def entropy_cal(p):

  return -p*np.log(p)+(1-p)*np.log(1-p)

def eval_decision_tree(tree, test_X):

#Takes in a tree, and a bunch of instances X and 
#returns the tree predicted values at those instances.

  nodes = len(tree)
  pred_Y = np.zeros((test_X.shape[0]))

  for k in range(test_X.shape[0]):
    next_node = 1
    while next_node<=nodes :
      if tree[next_node][0]=='none':
        if tree[next_node][2]=='1':
          pred_Y[k] = 1
        if tree[next_node][2]=='-1':
          pred_Y[k] = -1
        break;
      attr_choice = tree[next_node][0]
      threshold = tree[next_node][1]
      if test_X[k,attr_choice]>= threshold:
        if next_node > 1:
          next_node = next_node + 3
        if next_node == 1:
          next_node = next_node + 2
      if test_X[k,attr_choice] < threshold:
        if next_node > 1:
          next_node = next_node + 2
        if next_node == 1:
          next_node = next_node + 1   
      
  return pred_Y

# CodeWrite cell
# Write code here for doing validation to find the best hyperparameters (i.e. num_nodes_stop)
# Also Generate the numbers that you report below. 
# Repeat with criterion set to entropy also.
p = 0
test_err_acc = np.zeros(4)
test_err_entr = np.zeros(4)
train_err_acc = np.zeros(4)
train_err_entr = np.zeros(4)
data1_1 = np.load('Data/dataset_A.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
num_nodes_hyperparam = [250,300,400,500,600,700,800,900]
acc1 = np.zeros(len(num_nodes_hyperparam))
acc2 = np.zeros(len(num_nodes_hyperparam))
n = np.zeros(len(num_nodes_hyperparam))
for iter in range(len(num_nodes_hyperparam)):
  tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='accuracy')
  tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='entropy')
  val_X = X_train[0:200]
  val_Y = Y_train[0:200]
  pred_Y1 = eval_decision_tree(tree1, val_X)  
  acc1[iter] = 1 - len(val_Y[val_Y==pred_Y1])/len(val_Y)
  pred_Y2 = eval_decision_tree(tree2, val_X)  
  acc2[iter] = 1 - len(val_Y[val_Y==pred_Y2])/len(val_Y)

print(acc1,acc2)
nodes_optimal_acc_a = num_nodes_hyperparam[np.where(acc1 == np.amin(acc1))[0][0]]
print(nodes_optimal_acc_a,'p')
train_err_acc[p] = np.amin(acc1)
nodes_optimal_entr_a = num_nodes_hyperparam[np.where(acc2 == np.amin(acc2))[0][0]]
print(nodes_optimal_entr_a,'p')
train_err_entr[p] = np.amin(acc2)
tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_a, criterion='accuracy')
tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_entr_a, criterion='entropy')
pred_Y1 = eval_decision_tree(tree1, X_test)  
test_err_acc[p] = 1 - len(Y_test[Y_test==pred_Y1])/len(Y_test)
pred_Y2 = eval_decision_tree(tree2, X_test)  
test_err_entr[p] = 1 - len(Y_test[Y_test==pred_Y2])/len(Y_test)
p = p+1

data1_1 = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
num_nodes_hyperparam = [250,300,400,500,600,700,800,900]
acc1 = np.zeros(len(num_nodes_hyperparam))
acc2 = np.zeros(len(num_nodes_hyperparam))
n = np.zeros(len(num_nodes_hyperparam))
for iter in range(len(num_nodes_hyperparam)):
  tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='accuracy')
  tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='entropy')
  val_X = X_train[0:200]
  val_Y = Y_train[0:200]
  pred_Y1 = eval_decision_tree(tree1, val_X)  
  acc1[iter] = 1 - len(val_Y[val_Y==pred_Y1])/len(val_Y)
  pred_Y2 = eval_decision_tree(tree2, val_X)  
  acc2[iter] = 1 - len(val_Y[val_Y==pred_Y2])/len(val_Y)

print(acc1,acc2)
nodes_optimal_acc_b = num_nodes_hyperparam[np.where(acc1 == np.amin(acc1))[0][0]]
train_err_acc[p] = np.amin(acc1)
nodes_optimal_entr_b = num_nodes_hyperparam[np.where(acc2 == np.amin(acc2))[0][0]]
train_err_entr[p] = np.amin(acc2)
tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_b, criterion='accuracy')
tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_entr_b, criterion='entropy')
pred_Y1 = eval_decision_tree(tree1, X_test)  
test_err_acc[p] = 1 - len(Y_test[Y_test==pred_Y1])/len(Y_test)
pred_Y2 = eval_decision_tree(tree2, X_test)  
test_err_entr[p] = 1 - len(Y_test[Y_test==pred_Y2])/len(Y_test)
p = p+1

data1_1 = np.load('Data/dataset_C.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
num_nodes_hyperparam = [100,200,250,300,400,500,600,700,800,900]
acc1 = np.zeros(len(num_nodes_hyperparam))
acc2 = np.zeros(len(num_nodes_hyperparam))
n = np.zeros(len(num_nodes_hyperparam))
for iter in range(len(num_nodes_hyperparam)):
  tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='accuracy')
  tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='entropy')
  val_X = X_train[0:200]
  val_Y = Y_train[0:200]
  pred_Y1 = eval_decision_tree(tree1, val_X)  
  acc1[iter] = 1 - len(val_Y[val_Y==pred_Y1])/len(val_Y)
  pred_Y2 = eval_decision_tree(tree2, val_X)  
  acc2[iter] = 1 - len(val_Y[val_Y==pred_Y2])/len(val_Y)

print(acc1,acc2)
nodes_optimal_acc_c = num_nodes_hyperparam[np.where(acc1 == np.amin(acc1))[0][0]]
train_err_acc[p] = np.amin(acc1)
nodes_optimal_entr_c = num_nodes_hyperparam[np.where(acc2 == np.amin(acc2))[0][0]]
train_err_entr[p] = np.amin(acc2)
tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_c, criterion='accuracy')
tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_entr_c, criterion='entropy')
pred_Y1 = eval_decision_tree(tree1, X_test)  
test_err_acc[p] = 1 - len(Y_test[Y_test==pred_Y1])/len(Y_test)
pred_Y2 = eval_decision_tree(tree2, X_test)  
test_err_entr[p] = 1 - len(Y_test[Y_test==pred_Y2])/len(Y_test)
p = p+1

data1_1 = np.load('Data/dataset_D.npz')
X_train, Y_train, X_test, Y_test = data1_1['arr_0'],data1_1['arr_1'],data1_1['arr_2'],data1_1['arr_3']
num_nodes_hyperparam = [30,50,100,200,250,300,400,500,600,700,800,900]
acc1 = np.zeros(len(num_nodes_hyperparam))
acc2 = np.zeros(len(num_nodes_hyperparam))
n = np.zeros(len(num_nodes_hyperparam))
for iter in range(len(num_nodes_hyperparam)):
  tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='accuracy')
  tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=num_nodes_hyperparam[iter], criterion='entropy')
  val_X = X_train[0:200]
  val_Y = Y_train[0:200]
  pred_Y1 = eval_decision_tree(tree1, val_X)  
  acc1[iter] = 1 - len(val_Y[val_Y==pred_Y1])/len(val_Y)
  pred_Y2 = eval_decision_tree(tree2, val_X)  
  acc2[iter] = 1 - len(val_Y[val_Y==pred_Y2])/len(val_Y)

print(acc1,acc2)
nodes_optimal_acc_d = num_nodes_hyperparam[np.where(acc1 == np.amin(acc1))[0][0]]
train_err_acc[p] = np.amin(acc1)
nodes_optimal_entr_d = num_nodes_hyperparam[np.where(acc2 == np.amin(acc2))[0][0]]
train_err_entr[p] = np.amin(acc2)
tree1 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_d, criterion='accuracy')
tree2 = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_entr_d, criterion='entropy')
pred_Y1 = eval_decision_tree(tree1, X_test)  
test_err_acc[p] = 1 - len(Y_test[Y_test==pred_Y1])/len(Y_test)
pred_Y2 = eval_decision_tree(tree2, X_test)  
test_err_entr[p] = 1 - len(Y_test[Y_test==pred_Y2])/len(Y_test)

print(train_err_acc)
print(test_err_acc)
print(train_err_entr)
print(test_err_entr)
print(nodes_optimal_acc_a,nodes_optimal_acc_b,nodes_optimal_acc_c,nodes_optimal_acc_d)
print(nodes_optimal_entr_a,nodes_optimal_entr_b,nodes_optimal_entr_c,nodes_optimal_entr_d)

"""TextWrite cell: Give your observations and the list of hyperparameter choices and train zero-one error  and test zero-one error, for all 4 datasets (2 real world and 2 synthetic).  

When accuracy is the criterion used : 

Dataset | Stopping node choice | Train zero-one error | Test zero-one error
--- |--- |--- |---
A | 250 | 7.5 | 12.6
B | 400 | 25 | 27.2
C | 100 | 9 | 21.8
D | 30 | 5.5 | 13.6

When entropy is the criterion used : 

Dataset | Stopping node choice | Train zero-one error | Test zero-one error
--- |--- |--- |---
A
B
C
D
"""

## Codewrite cell: Generate plots of learned decision tree classifier on dataset_A and datasset_B.
# Plots should give both the learned classifier and the train data. 
# Plots only required for the accuracy criterion.
# Similar to  Bishop Figure 4.5 (with just two classes here.)
# Total number of plots = 2 

data_A = np.load('Data/dataset_A.npz')
X_train, Y_train, X_test, Y_test = data_A['arr_0'],data_A['arr_1'],data_A['arr_2'],data_A['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])


X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
tree = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_a, criterion='accuracy')
pred_Y = eval_decision_tree(tree, test_samples)

plt.figure(0)
f, (ax1) = plt.subplots(1,1,sharex=False,sharey=True,figsize=(15,7.5))
ax1.contourf(X,Y,pred_Y.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('Learned decision tree on Dataset A')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 
plt.show()

data_B = np.load('Data/dataset_B.npz')
X_train, Y_train, X_test, Y_test = data_B['arr_0'],data_B['arr_1'],data_B['arr_2'],data_B['arr_3']

X_min = min(X_train[:,0]),min(X_train[:,1])
X_max = max(X_train[:,0]),max(X_train[:,1])


X,Y = np.meshgrid(np.arange(X_min[0]-0.5,X_max[0]+0.5,0.05),np.arange(X_min[1]-0.5,X_max[1]+0.5,0.05))
test_samples= np.concatenate([X.reshape(-1,1),Y.reshape(-1,1)],axis=1)
tree = train_decision_tree(X_train, Y_train, num_nodes_stop=nodes_optimal_acc_b, criterion='accuracy')
pred_Y = eval_decision_tree(tree, test_samples)

plt.figure(1)
f, (ax1) = plt.subplots(1,1,sharex=False,sharey=True,figsize=(15,7.5))
ax1.contourf(X,Y,pred_Y.reshape(X.shape),colors=['#ff796c','#96f97b'])
ax1.scatter(X_train[Y_train==1][:,0],X_train[Y_train==1][:,1],s=2,c='g',label='Class 1')
ax1.scatter(X_train[Y_train==-1][:,0],X_train[Y_train==-1][:,1],s=2,c='#d9544d',label='Class -1')
ax1.set_title('Learned decision tree on Dataset B')
ax1.set_xlabel(r'$x_{1}\rightarrow$',size=15)
ax1.set_ylabel(r'$x_{2}\rightarrow$',size=15)
ax1.legend() 
plt.show()

"""# 4 Random Forest classifier

Write code for learning RandomForests below. Fix the following hyper parameters: (Fraction of data to learn tree=0.5, Fraction of number of features chosen in each node=0.5, num_nodes_stop=1).  Choose the number of trees to add in the forest by using a validation set. You may use a slightly modified version of the decision tree code you had written earlier.

Write code for running in the cell after the nest. (You may be asked to demonstrate your code during the viva using this cell.) 

In text cell after that report the following numbers you get by running appropriate code:

For all 4 data sets (A,B,C,D)  report the best number of trees found. Report the training and test zero-one error for those hyperparameters.

For the synthetic classification datasets (datasets A and B) in 2-dimensions, also illustrate the learned classifier for each kernel setting. Do this in the last codeWrite cell for this question.
"""

# CodeWrite cell
# Write Random Forest classifier. 
def train_random_forest(X, Y, num_trees=10, num_nodes_stop=1, 
                        criterion='accuracy', a=0.5, b=0.5):
""" Returns a random forest trained on X and Y. 
Trains num_trees.
Stops splitting nodes in each tree when a node has hit a size of "num_nodes_stop" or lower.
Split criterion can be either 'accuracy' or 'entropy'.
Fraction of data used per tree = a
Fraction of features used in each node = b
Returns a random forest (In whatever format that you find appropriate)
"""
    

def eval_random_forest(random_forest, test_X):
""" Takes in a  random forest object (hhowever you want to store it), and a bunch of instances X and 
returns the tree predicted values at those instances."""

# CodeWrite cell
# Write code for choosing the best hyperparameters (num_trees, num_nodes_stop)
# Write code here for generating the numbers that you report below.
# Repeat above for criterion set to entropy also.

"""TextWrite cell: Give your observations and the list of hyperparameter choices and train zero-one error  and test zero-one error, for all 4 datasets (2 real world and 2 synthetic).  

"""

## Codewrite cell: Generate plots of learned Random Forest classifier on dataset_A and datasset_B.
# Plots should give both the learned classifier and the train data. 
# Plots required only for the accuracy criterion.
# Similar to  Bishop Figure 4.5 (with just two classes here.)
# Total number of plots = 2

"""# 5 AdaBoost

Write code for learning using AdaBoost below. Use 3 different weak learners below. (You may reuse code written above)

1. 1 node decision tree 
2. Decision tree of fixed depth = 3 (Root, child, grand child)
3. Decision tree of fixed depth = 7 (Root, child, grand child)

Run for 50 iterations. You may use the accuracy split criterion for all the three weak learners.

Write code for running in the next cell. (You may be asked to demonstrate your code during the viva using this cell.) 

In text cell after that report the following numbers you get by running appropriate code:

For all 4 data sets (A,B,C,D)  plot the train and test accuracy vs epochs. A total of 12 plots is expected. 4 datasets * 3 weak learners. Each plot should contain two curves, train and test error.  

For the synthetic classification datasets (datasets A and B) in 2-dimensions, also illustrate the learned classifier for each weak learner setting. A total of 6 contourf style plots are expected here. Do this in the last codeWrite cell for this question.

Summarise your observations in the last textwrite cell.
"""

# Codewrite cell
# Write code to run here (no plotting)

# Codewrite cell princeton
# Plots for iteration vs error here

# Codewrite cell 
# Plots for illustrating the classifier here

"""Textwrite cell:"""